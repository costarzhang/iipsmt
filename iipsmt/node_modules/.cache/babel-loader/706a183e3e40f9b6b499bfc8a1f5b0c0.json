{"ast":null,"code":"import { Base } from \"../base\";\nimport { isArray, isNumber } from \"../../util\";\nimport Body from './body';\nimport Quad from './quad';\nimport QuadTree from './quadTree';\nexport class ForceAtlas2Layout extends Base {\n  constructor(options) {\n    super();\n    /** 布局中心 */\n\n    this.center = [0, 0];\n    /** 宽度 */\n\n    this.width = 300;\n    /** 高度 */\n\n    this.height = 300;\n    this.nodes = [];\n    this.edges = [];\n    /**\n     * the parameter for repulsive forces,\n     * it will scale the layout but won't change the layout\n     * larger the kr, looser the layout\n     * @type  {number}\n     */\n\n    this.kr = 5;\n    /**\n     * the parameter for gravity forces\n     * @type  {number}\n     */\n\n    this.kg = 1;\n    /**\n     * modes:\n     * 'normal' for normal using\n     * 'linlog' for compact clusters.\n     * @type  {string}\n     */\n\n    this.mode = 'normal';\n    /**\n     * whether preventing the node overlapping\n     * @type  {boolean}\n     */\n\n    this.preventOverlap = false;\n    /**\n     * whether active the dissuade hub mode\n     * true: grant authorities (nodes with a high indegree)\n     * a more central position than hubs (nodes with a high outdegree)\n     * @type  {boolean}\n     */\n\n    this.dissuadeHubs = false;\n    /**\n     * whether active the barnes hut optimization on computing repulsive forces\n     * @type  {boolean}\n     */\n\n    this.barnesHut = false;\n    /**\n     * the max iteration number\n     * @type  {number}\n     */\n\n    this.maxIteration = 0;\n    /**\n     * control the global velocity\n     * defualt: 0.1(gephi)\n     * @type  {number}\n     */\n\n    this.ks = 0.1;\n    /**\n     * the max global velocity\n     * @type  {number}\n     */\n\n    this.ksmax = 10;\n    /**\n     * the tolerance for the global swinging\n     * @type  {number}\n     */\n\n    this.tao = 0.1;\n    /**\n     * the function of layout complete listener, display the legend and minimap after layout\n     * @type  {function}\n     */\n\n    this.onLayoutEnd = () => {};\n    /**\n     * activate prune or not.\n     * prune the leaves during most iterations, layout the leaves in the last 50 iteraitons.\n     * if prune === '', it will be activated when the nodes number > 100\n     * note that it will reduce the quality of the layout\n     * @type  {boolean}\n     */\n\n\n    this.prune = false;\n    this.updateCfg(options);\n  }\n\n  getDefaultCfg() {\n    return {};\n  } // execute the layout\n\n\n  execute() {\n    const self = this;\n    let {\n      nodes,\n      maxIteration,\n      onLayoutEnd,\n      prune\n    } = self;\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    } // the whidth of each nodes\n\n\n    const sizes = [];\n    const nodeNum = nodes.length;\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      const node = nodes[i];\n      let nodeWidth = 10;\n      let nodeHeight = 10;\n\n      if (isNumber(node.size)) {\n        nodeWidth = node.size;\n        nodeHeight = node.size;\n      }\n\n      if (isArray(node.size)) {\n        if (!isNaN(node.size[0])) nodeWidth = node.size[0];\n        if (!isNaN(node.size[1])) nodeHeight = node.size[1];\n      }\n\n      if (self.getWidth && !isNaN(self.getWidth(node))) nodeHeight = self.getWidth(node);\n      if (self.getHeight && !isNaN(self.getHeight(node))) nodeWidth = self.getHeight(node);\n      const maxSize = Math.max(nodeWidth, nodeHeight);\n      sizes.push(maxSize);\n    }\n\n    if (!self.barnesHut && nodeNum > 250) self.barnesHut = true;\n    if (!self.prune && nodeNum > 100) self.prune = true;\n\n    if (this.maxIteration === 0 && !self.prune) {\n      maxIteration = 250;\n      if (nodeNum <= 200 && nodeNum > 100) maxIteration = 1000;else if (nodeNum > 200) maxIteration = 1200;\n      this.maxIteration = maxIteration;\n    } else if (this.maxIteration === 0 && prune) {\n      maxIteration = 100;\n      if (nodeNum <= 200 && nodeNum > 100) maxIteration = 500;else if (nodeNum > 200) maxIteration = 950;\n      this.maxIteration = maxIteration;\n    }\n\n    if (!self.kr) {\n      self.kr = 50;\n      if (nodeNum > 100 && nodeNum <= 500) self.kr = 20;else if (nodeNum > 500) self.kr = 1;\n    }\n\n    if (!self.kg) {\n      self.kg = 20;\n      if (nodeNum > 100 && nodeNum <= 500) self.kg = 10;else if (nodeNum > 500) self.kg = 1;\n    }\n\n    this.nodes = self.updateNodesByForces(sizes);\n    onLayoutEnd();\n  }\n\n  updateNodesByForces(sizes) {\n    const self = this;\n    let {\n      nodes,\n      edges,\n      maxIteration\n    } = self;\n    const nonLoopEdges = edges.filter(edge => {\n      return edge.source !== edge.target;\n    });\n    const size = nodes.length;\n    const esize = nonLoopEdges.length;\n    const degrees = [];\n    const idMap = {};\n    const edgeEndsIdMap = {};\n    const Es = [];\n\n    for (let i = 0; i < size; i += 1) {\n      idMap[nodes[i].id] = i;\n      degrees[i] = 0;\n\n      if (nodes[i].x === undefined || isNaN(nodes[i].x)) {\n        nodes[i].x = Math.random() * 1000;\n      }\n\n      if (nodes[i].y === undefined || isNaN(nodes[i].y)) {\n        nodes[i].y = Math.random() * 1000;\n      }\n\n      Es.push({\n        x: nodes[i].x,\n        y: nodes[i].y\n      });\n    }\n\n    for (let i = 0; i < esize; i += 1) {\n      let node1;\n      let node2;\n      let sIdx = 0,\n          tIdx = 0;\n\n      for (let j = 0; j < size; j += 1) {\n        if (nodes[j].id === nonLoopEdges[i].source) {\n          node1 = nodes[j];\n          sIdx = j;\n        } else if (nodes[j].id === nonLoopEdges[i].target) {\n          node2 = nodes[j];\n          tIdx = j;\n        }\n\n        edgeEndsIdMap[i] = {\n          sourceIdx: sIdx,\n          targetIdx: tIdx\n        };\n      }\n\n      if (node1) degrees[idMap[node1.id]] += 1;\n      if (node2) degrees[idMap[node2.id]] += 1;\n    }\n\n    let iteration = maxIteration;\n    nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes); // if prune, place the leaves around their parents, and then re-layout for several iterations.\n\n    if (self.prune) {\n      for (let j = 0; j < esize; j += 1) {\n        if (degrees[edgeEndsIdMap[j].sourceIdx] <= 1) {\n          nodes[edgeEndsIdMap[j].sourceIdx].x = nodes[edgeEndsIdMap[j].targetIdx].x;\n          nodes[edgeEndsIdMap[j].sourceIdx].y = nodes[edgeEndsIdMap[j].targetIdx].y;\n        } else if (degrees[edgeEndsIdMap[j].targetIdx] <= 1) {\n          nodes[edgeEndsIdMap[j].targetIdx].x = nodes[edgeEndsIdMap[j].sourceIdx].x;\n          nodes[edgeEndsIdMap[j].targetIdx].y = nodes[edgeEndsIdMap[j].sourceIdx].y;\n        }\n      }\n\n      self.prune = false;\n      self.barnesHut = false;\n      iteration = 100;\n      nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n    }\n\n    return nodes;\n  }\n\n  iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes) {\n    const self = this;\n    let {\n      nodes,\n      kr,\n      preventOverlap,\n      barnesHut\n    } = self;\n    const nodeNum = nodes.length;\n    let sg = 0;\n    const krPrime = 100;\n    let iter = iteration;\n    const prevoIter = 50;\n    let forces = [];\n    const preForces = [];\n    const bodies = [];\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      forces[2 * i] = 0;\n      forces[2 * i + 1] = 0;\n\n      if (barnesHut) {\n        let params = {\n          id: i,\n          rx: nodes[i].x,\n          ry: nodes[i].y,\n          mass: 1,\n          g: kr,\n          degree: degrees[i]\n        };\n        bodies[i] = new Body(params);\n      }\n    }\n\n    while (iter > 0) {\n      for (let i = 0; i < nodeNum; i += 1) {\n        preForces[2 * i] = forces[2 * i];\n        preForces[2 * i + 1] = forces[2 * i + 1];\n        forces[2 * i] = 0;\n        forces[2 * i + 1] = 0;\n      } // attractive forces, existing on every actual edge\n\n\n      forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces); // repulsive forces and Gravity, existing on every node pair\n      // if preventOverlap, using the no-optimized method in the last prevoIter instead.\n\n      if (barnesHut && (preventOverlap && iter > prevoIter || !preventOverlap)) {\n        forces = this.getOptRepGraForces(forces, bodies, degrees);\n      } else {\n        forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);\n      } // update the positions\n\n\n      const res = this.updatePos(forces, preForces, sg, degrees);\n      nodes = res.nodes;\n      sg = res.sg;\n      iter--;\n      if (self.tick) self.tick();\n    }\n\n    ;\n    return nodes;\n  }\n\n  getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces) {\n    const self = this;\n    const {\n      nodes,\n      preventOverlap,\n      dissuadeHubs,\n      mode,\n      prune\n    } = self;\n\n    for (let i = 0; i < esize; i += 1) {\n      const sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];\n      const sourceIdx = edgeEndsIdMap[i].sourceIdx;\n      const targetNode = nodes[edgeEndsIdMap[i].targetIdx];\n      const targetIdx = edgeEndsIdMap[i].targetIdx;\n      if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1)) continue;\n      let dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];\n      let eucliDis = Math.hypot(dir[0], dir[1]);\n      eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      if (preventOverlap && iter < prevoIter) eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];\n      let Fa1 = eucliDis;\n      let Fa2 = Fa1;\n\n      if (mode === 'linlog') {\n        Fa1 = Math.log(1 + eucliDis);\n        Fa2 = Fa1;\n      }\n\n      if (dissuadeHubs) {\n        Fa1 = eucliDis / degrees[sourceIdx];\n        Fa2 = eucliDis / degrees[targetIdx];\n      }\n\n      if (preventOverlap && iter < prevoIter && eucliDis <= 0) {\n        Fa1 = 0;\n        Fa2 = 0;\n      } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n        Fa1 = eucliDis;\n        Fa2 = eucliDis;\n      }\n\n      forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];\n      forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];\n      forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];\n      forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];\n    }\n\n    return forces;\n  }\n\n  getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees) {\n    const self = this;\n    const {\n      nodes,\n      preventOverlap,\n      kr,\n      kg,\n      center,\n      prune\n    } = self;\n    const nodeNum = nodes.length;\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      for (let j = i + 1; j < nodeNum; j += 1) {\n        if (prune && (degrees[i] <= 1 || degrees[j] <= 1)) continue;\n        let dir = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];\n        let eucliDis = Math.hypot(dir[0], dir[1]);\n        eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n        dir[0] = dir[0] / eucliDis;\n        dir[1] = dir[1] / eucliDis;\n        if (preventOverlap && iter < prevoIter) eucliDis = eucliDis - sizes[i] - sizes[j];\n        let Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis;\n\n        if (preventOverlap && iter < prevoIter && eucliDis < 0) {\n          Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);\n        } else if (preventOverlap && iter < prevoIter && eucliDis === 0) {\n          Fr = 0;\n        } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n          Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis;\n        }\n\n        forces[2 * i] -= Fr * dir[0];\n        forces[2 * j] += Fr * dir[0];\n        forces[2 * i + 1] -= Fr * dir[1];\n        forces[2 * j + 1] += Fr * dir[1];\n      } // gravity\n\n\n      let dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n      const eucliDis = Math.hypot(dir[0], dir[1]);\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      const Fg = kg * (degrees[i] + 1);\n      forces[2 * i] -= Fg * dir[0];\n      forces[2 * i + 1] -= Fg * dir[1];\n    }\n\n    return forces;\n  }\n\n  getOptRepGraForces(forces, bodies, degrees) {\n    const self = this;\n    const {\n      nodes,\n      kg,\n      center,\n      prune\n    } = self;\n    const nodeNum = nodes.length;\n    let minx = 9e10,\n        maxx = -9e10,\n        miny = 9e10,\n        maxy = -9e10;\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      bodies[i].setPos(nodes[i].x, nodes[i].y);\n      if (nodes[i].x >= maxx) maxx = nodes[i].x;\n      if (nodes[i].x <= minx) minx = nodes[i].x;\n      if (nodes[i].y >= maxy) maxy = nodes[i].y;\n      if (nodes[i].y <= miny) miny = nodes[i].y;\n    }\n\n    let width = Math.max(maxx - minx, maxy - miny);\n    let quadParams = {\n      xmid: (maxx + minx) / 2,\n      ymid: (maxy + miny) / 2,\n      length: width,\n      massCenter: center,\n      mass: nodeNum\n    };\n    let quad = new Quad(quadParams);\n    let quadTree = new QuadTree(quad); // build the tree, insert the nodes(quads) into the tree\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      if (bodies[i].in(quad)) quadTree.insert(bodies[i]);\n    } // update the repulsive forces and the gravity.\n\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      bodies[i].resetForce();\n      quadTree.updateForce(bodies[i]);\n      forces[2 * i] -= bodies[i].fx;\n      forces[2 * i + 1] -= bodies[i].fy; // gravity\n\n      let dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n      let eucliDis = Math.hypot(dir[0], dir[1]);\n      eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      let Fg = kg * (degrees[i] + 1);\n      forces[2 * i] -= Fg * dir[0];\n      forces[2 * i + 1] -= Fg * dir[1];\n    }\n\n    return forces;\n  }\n\n  updatePos(forces, preForces, sg, degrees) {\n    const self = this;\n    let {\n      nodes,\n      ks,\n      tao,\n      prune,\n      ksmax\n    } = self;\n    const nodeNum = nodes.length;\n    let swgns = [];\n    let trans = []; // swg(G) and tra(G)\n\n    let swgG = 0;\n    let traG = 0;\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      const minus = [forces[2 * i] - preForces[2 * i], forces[2 * i + 1] - preForces[2 * i + 1]];\n      const minusNorm = Math.hypot(minus[0], minus[1]);\n      const add = [forces[2 * i] + preForces[2 * i], forces[2 * i + 1] + preForces[2 * i + 1]];\n      const addNorm = Math.hypot(add[0], add[1]);\n      swgns[i] = minusNorm;\n      trans[i] = addNorm / 2;\n      swgG += (degrees[i] + 1) * swgns[i];\n      traG += (degrees[i] + 1) * trans[i];\n    }\n\n    let preSG = sg;\n    sg = tao * traG / swgG;\n\n    if (preSG !== 0) {\n      sg = sg > 1.5 * preSG ? 1.5 * preSG : sg;\n    } // update the node positions\n\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      let sn = ks * sg / (1 + sg * Math.sqrt(swgns[i]));\n      let absForce = Math.hypot(forces[2 * i], forces[2 * i + 1]);\n      absForce = absForce < 0.0001 ? 0.0001 : absForce;\n      const max = ksmax / absForce;\n      sn = sn > max ? max : sn;\n      const dnx = sn * forces[2 * i];\n      const dny = sn * forces[2 * i + 1];\n      nodes[i].x += dnx;\n      nodes[i].y += dny;\n    }\n\n    return {\n      nodes,\n      sg\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../src/layout/forceAtlas2/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Base } from \"../base\";\nimport { isArray, isNumber } from \"../../util\";\nimport Body from './body';\nimport Quad from './quad';\nimport QuadTree from './quadTree';\nexport class ForceAtlas2Layout extends Base {\n    constructor(options) {\n        super();\n        /** 布局中心 */\n        this.center = [0, 0];\n        /** 宽度 */\n        this.width = 300;\n        /** 高度 */\n        this.height = 300;\n        this.nodes = [];\n        this.edges = [];\n        /**\n         * the parameter for repulsive forces,\n         * it will scale the layout but won't change the layout\n         * larger the kr, looser the layout\n         * @type  {number}\n         */\n        this.kr = 5;\n        /**\n         * the parameter for gravity forces\n         * @type  {number}\n         */\n        this.kg = 1;\n        /**\n         * modes:\n         * 'normal' for normal using\n         * 'linlog' for compact clusters.\n         * @type  {string}\n         */\n        this.mode = 'normal';\n        /**\n         * whether preventing the node overlapping\n         * @type  {boolean}\n         */\n        this.preventOverlap = false;\n        /**\n         * whether active the dissuade hub mode\n         * true: grant authorities (nodes with a high indegree)\n         * a more central position than hubs (nodes with a high outdegree)\n         * @type  {boolean}\n         */\n        this.dissuadeHubs = false;\n        /**\n         * whether active the barnes hut optimization on computing repulsive forces\n         * @type  {boolean}\n         */\n        this.barnesHut = false;\n        /**\n         * the max iteration number\n         * @type  {number}\n         */\n        this.maxIteration = 0;\n        /**\n         * control the global velocity\n         * defualt: 0.1(gephi)\n         * @type  {number}\n         */\n        this.ks = 0.1;\n        /**\n         * the max global velocity\n         * @type  {number}\n         */\n        this.ksmax = 10;\n        /**\n         * the tolerance for the global swinging\n         * @type  {number}\n         */\n        this.tao = 0.1;\n        /**\n         * the function of layout complete listener, display the legend and minimap after layout\n         * @type  {function}\n         */\n        this.onLayoutEnd = () => { };\n        /**\n         * activate prune or not.\n         * prune the leaves during most iterations, layout the leaves in the last 50 iteraitons.\n         * if prune === '', it will be activated when the nodes number > 100\n         * note that it will reduce the quality of the layout\n         * @type  {boolean}\n         */\n        this.prune = false;\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {};\n    }\n    // execute the layout\n    execute() {\n        const self = this;\n        let { nodes, maxIteration, onLayoutEnd, prune, } = self;\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        // the whidth of each nodes\n        const sizes = [];\n        const nodeNum = nodes.length;\n        for (let i = 0; i < nodeNum; i += 1) {\n            const node = nodes[i];\n            let nodeWidth = 10;\n            let nodeHeight = 10;\n            if (isNumber(node.size)) {\n                nodeWidth = node.size;\n                nodeHeight = node.size;\n            }\n            if (isArray(node.size)) {\n                if (!isNaN(node.size[0]))\n                    nodeWidth = node.size[0];\n                if (!isNaN(node.size[1]))\n                    nodeHeight = node.size[1];\n            }\n            if (self.getWidth && !isNaN(self.getWidth(node)))\n                nodeHeight = self.getWidth(node);\n            if (self.getHeight && !isNaN(self.getHeight(node)))\n                nodeWidth = self.getHeight(node);\n            const maxSize = Math.max(nodeWidth, nodeHeight);\n            sizes.push(maxSize);\n        }\n        if (!self.barnesHut && nodeNum > 250)\n            self.barnesHut = true;\n        if (!self.prune && nodeNum > 100)\n            self.prune = true;\n        if (this.maxIteration === 0 && !self.prune) {\n            maxIteration = 250;\n            if (nodeNum <= 200 && nodeNum > 100)\n                maxIteration = 1000;\n            else if (nodeNum > 200)\n                maxIteration = 1200;\n            this.maxIteration = maxIteration;\n        }\n        else if (this.maxIteration === 0 && prune) {\n            maxIteration = 100;\n            if (nodeNum <= 200 && nodeNum > 100)\n                maxIteration = 500;\n            else if (nodeNum > 200)\n                maxIteration = 950;\n            this.maxIteration = maxIteration;\n        }\n        if (!self.kr) {\n            self.kr = 50;\n            if (nodeNum > 100 && nodeNum <= 500)\n                self.kr = 20;\n            else if (nodeNum > 500)\n                self.kr = 1;\n        }\n        if (!self.kg) {\n            self.kg = 20;\n            if (nodeNum > 100 && nodeNum <= 500)\n                self.kg = 10;\n            else if (nodeNum > 500)\n                self.kg = 1;\n        }\n        this.nodes = self.updateNodesByForces(sizes);\n        onLayoutEnd();\n    }\n    updateNodesByForces(sizes) {\n        const self = this;\n        let { nodes, edges, maxIteration, } = self;\n        const nonLoopEdges = edges.filter((edge) => {\n            return edge.source !== edge.target;\n        });\n        const size = nodes.length;\n        const esize = nonLoopEdges.length;\n        const degrees = [];\n        const idMap = {};\n        const edgeEndsIdMap = {};\n        const Es = [];\n        for (let i = 0; i < size; i += 1) {\n            idMap[nodes[i].id] = i;\n            degrees[i] = 0;\n            if (nodes[i].x === undefined || isNaN(nodes[i].x)) {\n                nodes[i].x = Math.random() * 1000;\n            }\n            if (nodes[i].y === undefined || isNaN(nodes[i].y)) {\n                nodes[i].y = Math.random() * 1000;\n            }\n            Es.push({ x: nodes[i].x, y: nodes[i].y });\n        }\n        for (let i = 0; i < esize; i += 1) {\n            let node1;\n            let node2;\n            let sIdx = 0, tIdx = 0;\n            for (let j = 0; j < size; j += 1) {\n                if (nodes[j].id === nonLoopEdges[i].source) {\n                    node1 = nodes[j];\n                    sIdx = j;\n                }\n                else if (nodes[j].id === nonLoopEdges[i].target) {\n                    node2 = nodes[j];\n                    tIdx = j;\n                }\n                edgeEndsIdMap[i] = { sourceIdx: sIdx, targetIdx: tIdx };\n            }\n            if (node1)\n                degrees[idMap[node1.id]] += 1;\n            if (node2)\n                degrees[idMap[node2.id]] += 1;\n        }\n        let iteration = maxIteration;\n        nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n        // if prune, place the leaves around their parents, and then re-layout for several iterations.\n        if (self.prune) {\n            for (let j = 0; j < esize; j += 1) {\n                if (degrees[edgeEndsIdMap[j].sourceIdx] <= 1) {\n                    nodes[edgeEndsIdMap[j].sourceIdx].x = nodes[edgeEndsIdMap[j].targetIdx].x;\n                    nodes[edgeEndsIdMap[j].sourceIdx].y = nodes[edgeEndsIdMap[j].targetIdx].y;\n                }\n                else if (degrees[edgeEndsIdMap[j].targetIdx] <= 1) {\n                    nodes[edgeEndsIdMap[j].targetIdx].x = nodes[edgeEndsIdMap[j].sourceIdx].x;\n                    nodes[edgeEndsIdMap[j].targetIdx].y = nodes[edgeEndsIdMap[j].sourceIdx].y;\n                }\n            }\n            self.prune = false;\n            self.barnesHut = false;\n            iteration = 100;\n            nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n        }\n        return nodes;\n    }\n    iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes) {\n        const self = this;\n        let { nodes, kr, preventOverlap, barnesHut } = self;\n        const nodeNum = nodes.length;\n        let sg = 0;\n        const krPrime = 100;\n        let iter = iteration;\n        const prevoIter = 50;\n        let forces = [];\n        const preForces = [];\n        const bodies = [];\n        for (let i = 0; i < nodeNum; i += 1) {\n            forces[2 * i] = 0;\n            forces[2 * i + 1] = 0;\n            if (barnesHut) {\n                let params = {\n                    id: i,\n                    rx: nodes[i].x,\n                    ry: nodes[i].y,\n                    mass: 1,\n                    g: kr,\n                    degree: degrees[i]\n                };\n                bodies[i] = new Body(params);\n            }\n        }\n        while (iter > 0) {\n            for (let i = 0; i < nodeNum; i += 1) {\n                preForces[2 * i] = forces[2 * i];\n                preForces[2 * i + 1] = forces[2 * i + 1];\n                forces[2 * i] = 0;\n                forces[2 * i + 1] = 0;\n            }\n            // attractive forces, existing on every actual edge\n            forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces);\n            // repulsive forces and Gravity, existing on every node pair\n            // if preventOverlap, using the no-optimized method in the last prevoIter instead.\n            if (barnesHut && ((preventOverlap && iter > prevoIter) || !preventOverlap)) {\n                forces = this.getOptRepGraForces(forces, bodies, degrees);\n            }\n            else {\n                forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);\n            }\n            // update the positions\n            const res = this.updatePos(forces, preForces, sg, degrees);\n            nodes = res.nodes;\n            sg = res.sg;\n            iter--;\n            if (self.tick)\n                self.tick();\n        }\n        ;\n        return nodes;\n    }\n    getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces) {\n        const self = this;\n        const { nodes, preventOverlap, dissuadeHubs, mode, prune } = self;\n        for (let i = 0; i < esize; i += 1) {\n            const sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];\n            const sourceIdx = edgeEndsIdMap[i].sourceIdx;\n            const targetNode = nodes[edgeEndsIdMap[i].targetIdx];\n            const targetIdx = edgeEndsIdMap[i].targetIdx;\n            if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1))\n                continue;\n            let dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];\n            let eucliDis = Math.hypot(dir[0], dir[1]);\n            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            if (preventOverlap && iter < prevoIter)\n                eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];\n            let Fa1 = eucliDis;\n            let Fa2 = Fa1;\n            if (mode === 'linlog') {\n                Fa1 = Math.log(1 + eucliDis);\n                Fa2 = Fa1;\n            }\n            if (dissuadeHubs) {\n                Fa1 = eucliDis / degrees[sourceIdx];\n                Fa2 = eucliDis / degrees[targetIdx];\n            }\n            if (preventOverlap && iter < prevoIter && eucliDis <= 0) {\n                Fa1 = 0;\n                Fa2 = 0;\n            }\n            else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n                Fa1 = eucliDis;\n                Fa2 = eucliDis;\n            }\n            forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];\n            forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];\n            forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];\n            forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];\n        }\n        return forces;\n    }\n    getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees) {\n        const self = this;\n        const { nodes, preventOverlap, kr, kg, center, prune } = self;\n        const nodeNum = nodes.length;\n        for (let i = 0; i < nodeNum; i += 1) {\n            for (let j = i + 1; j < nodeNum; j += 1) {\n                if (prune && (degrees[i] <= 1 || degrees[j] <= 1))\n                    continue;\n                let dir = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];\n                let eucliDis = Math.hypot(dir[0], dir[1]);\n                eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n                dir[0] = dir[0] / eucliDis;\n                dir[1] = dir[1] / eucliDis;\n                if (preventOverlap && iter < prevoIter)\n                    eucliDis = eucliDis - sizes[i] - sizes[j];\n                let Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis;\n                if (preventOverlap && iter < prevoIter && eucliDis < 0) {\n                    Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);\n                }\n                else if (preventOverlap && iter < prevoIter && eucliDis === 0) {\n                    Fr = 0;\n                }\n                else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n                    Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis;\n                }\n                forces[2 * i] -= Fr * dir[0];\n                forces[2 * j] += Fr * dir[0];\n                forces[2 * i + 1] -= Fr * dir[1];\n                forces[2 * j + 1] += Fr * dir[1];\n            }\n            // gravity\n            let dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n            const eucliDis = Math.hypot(dir[0], dir[1]);\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            const Fg = kg * (degrees[i] + 1);\n            forces[2 * i] -= Fg * dir[0];\n            forces[2 * i + 1] -= Fg * dir[1];\n        }\n        return forces;\n    }\n    getOptRepGraForces(forces, bodies, degrees) {\n        const self = this;\n        const { nodes, kg, center, prune } = self;\n        const nodeNum = nodes.length;\n        let minx = 9e10, maxx = -9e10, miny = 9e10, maxy = -9e10;\n        for (let i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            bodies[i].setPos(nodes[i].x, nodes[i].y);\n            if (nodes[i].x >= maxx)\n                maxx = nodes[i].x;\n            if (nodes[i].x <= minx)\n                minx = nodes[i].x;\n            if (nodes[i].y >= maxy)\n                maxy = nodes[i].y;\n            if (nodes[i].y <= miny)\n                miny = nodes[i].y;\n        }\n        let width = Math.max(maxx - minx, maxy - miny);\n        let quadParams = {\n            xmid: (maxx + minx) / 2,\n            ymid: (maxy + miny) / 2,\n            length: width,\n            massCenter: center,\n            mass: nodeNum\n        };\n        let quad = new Quad(quadParams);\n        let quadTree = new QuadTree(quad);\n        // build the tree, insert the nodes(quads) into the tree\n        for (let i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            if (bodies[i].in(quad))\n                quadTree.insert(bodies[i]);\n        }\n        // update the repulsive forces and the gravity.\n        for (let i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            bodies[i].resetForce();\n            quadTree.updateForce(bodies[i]);\n            forces[2 * i] -= bodies[i].fx;\n            forces[2 * i + 1] -= bodies[i].fy;\n            // gravity\n            let dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n            let eucliDis = Math.hypot(dir[0], dir[1]);\n            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            let Fg = kg * (degrees[i] + 1);\n            forces[2 * i] -= Fg * dir[0];\n            forces[2 * i + 1] -= Fg * dir[1];\n        }\n        return forces;\n    }\n    updatePos(forces, preForces, sg, degrees) {\n        const self = this;\n        let { nodes, ks, tao, prune, ksmax } = self;\n        const nodeNum = nodes.length;\n        let swgns = [];\n        let trans = [];\n        // swg(G) and tra(G)\n        let swgG = 0;\n        let traG = 0;\n        for (let i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            const minus = [forces[2 * i] - preForces[2 * i],\n                forces[2 * i + 1] - preForces[2 * i + 1]\n            ];\n            const minusNorm = Math.hypot(minus[0], minus[1]);\n            const add = [forces[2 * i] + preForces[2 * i],\n                forces[2 * i + 1] + preForces[2 * i + 1]\n            ];\n            const addNorm = Math.hypot(add[0], add[1]);\n            swgns[i] = minusNorm;\n            trans[i] = addNorm / 2;\n            swgG += (degrees[i] + 1) * swgns[i];\n            traG += (degrees[i] + 1) * trans[i];\n        }\n        let preSG = sg;\n        sg = tao * traG / swgG;\n        if (preSG !== 0) {\n            sg = sg > (1.5 * preSG) ? (1.5 * preSG) : sg;\n        }\n        // update the node positions\n        for (let i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            let sn = ks * sg / (1 + sg * Math.sqrt(swgns[i]));\n            let absForce = Math.hypot(forces[2 * i], forces[2 * i + 1]);\n            absForce = absForce < 0.0001 ? 0.0001 : absForce;\n            const max = ksmax / absForce;\n            sn = sn > max ? max : sn;\n            const dnx = sn * forces[2 * i];\n            const dny = sn * forces[2 * i + 1];\n            nodes[i].x += dnx;\n            nodes[i].y += dny;\n        }\n        return { nodes, sg };\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}